#include "OLED64x128.h"
#include "i2c.h"

void send_OLED_command(char cmnd){
   TWI_Start();
  // _delay_ms(1000);
   TWI_Transmit_Add(OLED_I2C_Add);
   TWI_Transmit_byte(0x00); // 0x00 for command, 0x40 for data
   TWI_Transmit_byte(cmnd);
   TWI_Stop();
 }

void send_OLED_data(char data){
  TWI_Transmit_byte(data);
 }

/*
 * Initialize OLED:
 * Vcc generated by internal DC/DC circuit
 * Horizontal addressing mode
 * */
void OLED_init(){//in func. ro ba sample code haye SSD1306.cpp va OLED.ino moghayese kardam eyne hame****************
  send_OLED_command(0xAE);// Set Display Off
  send_OLED_command(0xD5);// Set DisplayClk Divide Ratio(Osc. Freq.)
  send_OLED_command(0x80);
  send_OLED_command(0xA8);// Set Multiples Ratio
  send_OLED_command(0x3F);
  send_OLED_command(0xD3);// Set Display Offset
  send_OLED_command(0x00);
  send_OLED_command(0x40);// Set Display Start Line
  send_OLED_command(0x8D);// Set Charge Pump
  send_OLED_command(0x14);// Vcc generated by internal DC/DC circuit

  // Set memory addressing mode: Horizontal addressing mode
  send_OLED_command(0x20);// SSD1306_MEMORYMODE
  send_OLED_command(0x00);// horizontal addressing mode

  send_OLED_command(0xA1);// Set Segment Re-Map
  send_OLED_command(0xC8);// Set COM Output Scan Direction
  send_OLED_command(0xDA);// Set COM Pins Hardware Configuration
  send_OLED_command(0x12);
  send_OLED_command(0x81);// Set Contrast Cntl
  send_OLED_command(0xCF);// Vcc generated by internal DC/DC circuit
  send_OLED_command(0xD9);// Set Pre-Charge Period
  send_OLED_command(0xF1);// Vcc generated by internal DC/DC circuit
  send_OLED_command(0xDB);// Set VCOMH Deselect Level
  send_OLED_command(0x40);
  send_OLED_command(0xA4);// Set Entire Display On/Off, entire display:on
  send_OLED_command(0xA6);// Set Normal/Inverse Display, set to normal     // Non-inverted display
  send_OLED_command(0xAF);// Set Display On // Turn display back on
}

/*
void update_screen() {
  set_column_add();
  set_page_add();
  // We have to send the buffer as 16 bytes packets
    // Our buffer is 1024 bytes long, 1024/16 = 64
    // We have to send 64 packets
  for(int j = 0; j < 64; j++) {
    TWI_Start();
      TWI_Transmit_Add(OLED_I2C_Add);
        TWI_Transmit_byte(0x40); // 0x00 for command, 0x40 for data
        for(int i = 0; i < 16; i++) {
          TWI_Transmit_byte(buffer[16*j + i]);
         }
        TWI_Stop();
      }
}
*/

/*
 * GDDRAM = 128 x 64 bits and devided to 8 pages
 * When one data byte is written into GDDRAM, all the rows image data of the same
 * page of the current column(8 bits) pointed by the column address pointer are filled.
 * Data bit D0 is written into the top row, while data bit D7 is written into bottom row.
 * */
void update_screen() {
  set_column_add();
  set_page_add();

  for(int page = 0; page < 8; page++) {
     TWI_Start();
   TWI_Transmit_Add(OLED_I2C_Add);
     TWI_Transmit_byte(0x40); // 0x00 for command, 0x40 for data
      for(int column = 0; column < 128; column++) {
         TWI_Transmit_byte(buffer[128*page + column]);
      }
      TWI_Stop();
  }
}

/*
 * Fills all the buffer with 0 to clear the screen
 * */
void clear_screen() {
	memset(buffer, 0, 1024);
	update_screen();
}

/*
 * Column_add: 3 bytes
 * Setup column start and end address
 * 128 column: Each column in one page is 8bit
 * */
void set_column_add(){
	send_OLED_command(0x21);// column add
	send_OLED_command(0x00);// start column
	send_OLED_command(0x7F);// end column=128
}

/*
 * Page_add: 3 bytes
 * Setup page start and end address
 * 8 pages: each page = 128 column x 8 row
* */
void set_page_add(){
	send_OLED_command(0x22);// page add
	send_OLED_command(0x00);// start page
	send_OLED_command(0x07);// end page
}

/*
 * This function write each character from 'fon_6x8' look up table and adds one byte 0x00 after each character
 * Depending on value of row and column, index is calculated and depending on index, character is written on related page
 * Each character cantains 5 bytes(5column)
 * 1byte empty: 1column equal to 0x00
 * Each byte fills one column of the page
 * index:(0~1023) number of each column on screen
 * 0~127:page0, 128~255:page1, 256~383:page2, 384~511:page3, 512~639:page4, 640~767:page5
 * 768~895:page6, 896~1023:page7
 * row  :(0~7) for each page
 * col*6: to protect characters from being written on each other;
 *      : the next character from same row is writen on next 6 columns
 * */
void wirte_character(unsigned char row, unsigned char col, unsigned char ch) {
     unsigned int index = 0;
     unsigned int i = 0;
  //   col -= 1;
  //   row -= 1;

     // check for out off range
     if ((col > OLED_WIDTH)||(col < 0)) return;
     if ((row > 7)||(row < 0)) return;

     index = (unsigned int) col * 6  + (unsigned int) row * OLED_WIDTH; // determines which byte(column) on screen

     // write character (5bytes + 1byte empty):
	 for (i = 0; i < 6; i++)
	 {
		 if (i==5)
		   buffer[index++] = 0x00; // write one column empty after character
		 else
		   buffer[index++] = font_6x8[ch - 32][i]; // write character
	 }
}


void write_text(unsigned char row, const unsigned char *dataPtr) {   //print small font text, text to print, should the text be scrollable(0/1)
   unsigned char col = 0;         // variable for col coordinate
 //  printf("Value of *dataPtr variable: %d\n", *dataPtr);  //prints value of x

   if (row < 0) row = 0;
   if (row <= (OLED_HIGHTH/8 - 1)) {
     while (*dataPtr) {           // loop to the end of string
       wirte_character(row, col, *dataPtr);
 //      printf("Address stored in dataPtr variable: %x\n", dataPtr);	//prints add of x where it is stored in memory

       col++;
       dataPtr++;
     }
  }
  return;
}
